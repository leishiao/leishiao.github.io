# 结构型模式：适配器，桥接，组合

## 结构型模式

结构型模式（Structural Pattern）描述如何将类或者对象结合在一起形成更大的结构。

结构型模式可以描述两种不同的东西，类与类的实例（即对象）。根据这一点，结构型模式可以分为类结构型模式和对象结构型模式。

类结构型模式关心类的组合，由多个类可以组成一个更大的系统，在类结构型模式中一般只存在**继承关系**和**实现关系**。

对象结构型模式关系类与对象的组合，通过**关联关系**使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。

## 适配器模式

**适配器模式（Adapter Pattern）定义：**

将一个类的接口转换成客户希望的另一个接口，适配器模式使接口不兼容的类可以一起工作，其别名为包装器（Wrapper）。适配器模式即可作为类结构型模式，也可以作为对象结构型模式。

英文定义：Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

**适配器模式结构：**

适配器模式包括类适配器和对象适配器，下面分别对两种适配器进行结构分析。

适配器包含如下角色：

1. Target(目标抽象类)

目标抽象类定义客户要用的特定领域的接口。

2. Adapter（适配器类）

适配器类可以调用适配者类的接口，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心。在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系；在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。

3. Adaptee（适配者类）

适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配。适配者类一般是一个具体类，这个类定义了客户希望使用的业务接口，在某些情况下甚至没有适配者类的源代码。

4. Client（客户类）

在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。

**协作：**

- Client在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。

**效果：**

类适配器和对象适配器有不同的权衡。

类适配器

- 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类及所有它的子类时，类适配器将不能胜任工作。
- 使得Adapter可以重新定义Adaptee的行为，因为Adapter是Adaptee的一个子类。

对象适配器

- 允许一个Adapter与多个Adaptee——即Adaptee本身以及他的所有子类同时工作。Adapter可以一次给所有Adaptee添加功能。
- 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并使得Adapter引用这个子类而不是引用Adaptee本身。

使用Adapter模式时需要考虑的其他一些因素有：

（1）Adapter的匹配程度	对Adaptee的接口与Target的接口进行匹配的工作量有个Adapter可能不一样。工作范围可能是，从简单的接口转换（例如改变操作名）到支持完全不同的操作集合。Adapter的工作量取决于Target接口与Adapter接口的相似程度。

**适用性：**

以下情况适用Adapter模式：

- 你想使用一个已经存在的类，而它的接口不符合你的需求。
- 你想创建一个可以复用的类，该类可以与不相关的类或不可预见的类协同工作
- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它们的父接口。（仅适用于对象Adapter）

**适配器模式扩展：**

缺省适配器模式（Default Adapter Pattern）的定义：当不需要实现接口提供的全部方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择地覆盖方法来实现需求。它适用于一个接口不想使用其所有方法的情况。

在缺省适配器模式中，包含三个角色：适配者接口、缺省适配器类、具体业务类。

**相关模式：**

Bridge模式的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而可以是它们相对独立的改变。

Decorator模式增强了其他对象的功能而同时又不改变它的接口。因此decorator对应用程序的透明性更好。结果是decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。

Proxy 模式在不改变它的接口的条件下，为另一个对象定义代理。

**小结：**

（1）适配器模式更多的是强调对代码的组织，而不是功能的实现。



## 桥接模式

**桥接模式（Bridge）定义：**

将抽象部分与它的实现部分分离，是他们都可以独立的变化。它是一种对象结构型模式，又称为柄体模式（Handle and Body)或接口模式（Interface）。

英文定义: Decouple an abstraction from its implementation so that the two can vary independently.

**动机：**

当一个抽象可能有多个实现时，通常用继承来协调他们。抽象类定义对该抽象的接口，而具体的子类则用不同的方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。

**桥接模式结构：**

桥接模式包含如下角色：

1. Abstraction（抽象类）

用于定义抽象类的接口，它一般是抽象类而不是接口。维护一个Implementor 类型的对象引用。可以包含抽线的业务方法和具体的业务方法。

2. RefinedAbstraction（扩充抽象类）

扩充由 Abstraction 定义的接口。

3. Implementor（实现类接口）

定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用 Implementor 中定义的方法，使用关联关系来替代继承关系。

4. ConcreteImplementor（具体实现类）

实现 Implementor 接口并定义它的具体实现。

**协作：**

Abstraction将client的请求转发给它的Implementor对象。

在抽象类 Abstraction 中定义了一个实现类接口的成员变量impl，再通过注入的方式给该对象赋值，一般该对象的可见性定义为 protected，以便在其之类中访问 Implementor 的方法。

**模式分析：**

理解桥接模式，重点是要理解如何将抽象化（Abstraction）和实现化（Implementation）脱耦，使得二者可以独立的变化。这里面包含了3个关键词，分别是抽象化、实现化和脱耦。

1. 抽象化

抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面像对象中，将对象的共同性质抽取出来形成类的过程就是抽象化的过程。

2. 实现化

针对抽象化给出的具体实现，就是实现化。抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是抽象化事物进一步具体化的产物。

3. 脱耦

脱耦就是将抽象化和实现化之间的耦合解脱开，或者说将它们间的强关联改成弱关联，将两个角色之间的继承关系改成关联关系。桥接模式中所谓的脱耦，就是指在一个软件的抽象化和实现化之间使用关联关系（组合或聚合关系）而不是继承关系，从而使两者可以相对独立的变化，这就是桥接模式的用意。

**适用性：**

以下情况使用Bridge模式：

- 你不希望在抽象和它的实现之间有一个固定的绑定关系。可能是因为，在程序运行时刻实现部分应可以被选择或切换。
- 类的抽象以及它的实现都因该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。
- 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。
- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**实现：**

（1）仅有一个Implementor
在仅有一个实现的时候，没有必要创建一个抽象的Implementor类。这是Bridge模式的退化情况；在Abstraction和Implementor之间有一种一对一的关系。

（2）创建正确的Implementor对象
当存在多个Implementor类的时候，应该用何种方法，在何时何处确定创建哪一个Implementor类呢？

- 通过传入构造器的参数确定实例化哪一个类。Collection类根据大小决定实例化哪一个类。链表的实现可以用于较小的collection类，而hash表则可用于较大的collection类。
- 首先选择一个缺省实现，然后根据需要改变这个实现。
- 引入一个factory对象（Abstract Factory）来装配Abstraction和Implementor。这种方法的优点是Abstraction类不和任何一个Implementor类直接耦合。

**效果：**

Bridge 模式有以下优点：

（1）分离接口及其实现部分
一个实现未必不变的地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。

（2）提高可扩充性
你可以独立地对 Abstraction 和 Implementor层次结构进行扩充。

**相关模式：**

Abstraction Factory 模式可以用来创建和配置一个特定的Bridge模式。
Adapter 模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用到。然而，Bridge模式则在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。

## 组合模式

**组合模式（Composite Pattern）定义：**

组合多个对象形成树形结构以表示”部分-整体“的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

**实用性**

- 你想表示对象的部分-整体层次结构。
- 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 

用得少，先不看咯。