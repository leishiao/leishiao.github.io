## 第 4 章  对 象 与 类

### 面向对象程序设计概述

面向对象程序设计 （ 简称 OOP ) 是当今主流的程序设计范型， Java 是完全面向对象的 ， 必须熟悉 OOP 才能
够编写 Java 程序

面向对象的程序是由对象组成的 ，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库 ，还有一些是自定义的 。究竟是自己构造对象 ，还是从外界购买对象完全取决于开发项目的预算和时间。 但是 ，从根本上说 ，只要对象能够满足要求，就不必关心其功能的具体实现过程 。 在OOP 中，不必关心对象的具体实现 ，只要能够满足用户的需求即可。

传统的结构化程序设计通过设计一系列的过程 （ 即算法 ） 来求解问题。 一旦确定了这些过程 ， 就要开始考虑存储数据的方式。这就是 算法 + 数据结构 = 程序 的原因，首先要确定如何操作数据 ， 然后再决定如何组织数据 ，以便于数据操作。 而 OOP 却调换了这个次序 ， 将数据放在第一位， 然后再考虑操作数据的算法 。

对于一些规模较小的问题 ，将其分解为过程的开发方式比较理想。而面向对象更加适用于解决规模较大的问题。

#### 类

类 （ class ) 是构造对象的模板或蓝图。由类构造 （ construct ) 对象的过程称为创建类的实例 （ instance ) 。

正如前面所看到的 ， 用 Java 编写的所有代码都位于某个类的内部 。标准的 Java 库提供了几千个类，尽管如此 ， 还是需要在Java 程序中创建一些自己的类 ， 以便描述应用程序所对应的问题域中的对象。

封装 （ encapsulation , 有时称为数据隐藏 ） 是与对象有关的一个重要概念 。 从形式上看 ，封装不过是将数据和行为组合在一个包中 ，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域 （ instance field ) , 操纵数据的过程称为方法 （ method )。 对于每个特定的类实例（ 对象 ）都有一组特定的实例域值， 这些值的集合就是这个对象的当前状态 （ state )。无论何时，只要向对象发送一个消息 ，它的状态就有可能发生改变。

实现封装的关键在于**绝对不能**让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了 “ 黑盒 ” 特征 ， 这是提高重用性和可靠性的关键。这意味着一个类可以全面地改变存储数据的方式， 只要仍旧使用同样的方法操作数据 ， 其他对象就不会知道或介意所发生的变化。

OOP 的另一个原则会让用户自定义 Java 类变得轻而易举， 这就是 ： 可以通过扩展一个类来建立另外一个新的类。 事实上 ， 在 Java 中 ， 所有的类都源自于一个 “神通广大的超类 ” ，它就是 Object。

在扩展一个已有的类时 ， 这个扩展后的新类具有所扩展的类的全部属性和方法。 在新类中， 只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为继承 （ inheritance )。

#### 对 象

同一个类的所有对象实例 ， 由于支持相同的行为而具有家族式的相似性。 对象的行为是用可调用的方法定义的。

每个对象都保存着描述当前特征的信息 。 这就是对象的状态 。 对象的状态可能会随着时间而发生改变， 但这种改变不会是自发的 。 对象状态的改变必须通过调用方法实现( 如果不经过方法调用就可以改变对象状态， 只能说明封装性遭到了破坏 ) 。

#### 识 别 类

传统的过程化程序设计， 必须从顶部的main 函数开始编写程序 。 在面向对象程序设计时没有所谓的 “ 顶部 ” 。 对于学习 OOP 的初学者来说常常会感觉无从下手 。 答案是 ： 首先从设计类开始， 然后再往每个类中添加方法。

识别类的简单规则是在分析问题的过程中寻找名词， 而方法对应着动词 。

当然 ， 所谓 “ 找名词与动词 ” 原则只是一种经验， 在创建类的时候 ， 哪些名词和动词是重要的完全取决于个人的开发经验。

#### 类之间的关系

在类之间， 最常见的关系有

> 依赖 （ “uses - a ” ）
> 聚合 （“ has - a ” ）
> 继承 （“is - a ” ）

**依赖** （ dependence ) , 即 “uses - a ” 关系 ， 是一种最明显的 、 最常见的关系。如果一个类的方法操纵另一个
类的对象， 我们就说一个类依赖于另一个类 。

应该尽可能地将相互依赖的类减至最少。如果类A 不知道 B 的存在 ， 它就不会关心 B的任何改变 （ 这意味着 B的改变不会导致 A 产生任何 bug ) 。 用软件工程的术语来说， 就是让类之间的耦合度最小。

**聚合** （ aggregation ) , 即 “ has - a ” 关系 ， 是一种具体且易于理解的关系。 例如 ，一个Order 对象包含一些 Item 对象 。 聚合关系意味着类 A 的对象包含类 B 的对象 。

**继承** （ inheritance ) , 即 “ is - a ” 关系， 是一种用于表示特殊与一般关系的 。

![1571475915975](C:\Users\leixiao\AppData\Roaming\Typora\typora-user-images\1571475915975.png)

### 使用预定义类

在 Java 中， 没有类就无法做任何事情。 然而 ， 并不是所有的类都具有面向对象特征。 例如， Math 类。

#### 对象与对象变量

要想使用对象，就必须首先构造对象 ，并指定其初始状态 。然后 ，对对象应用方法 。

在 Java 程序设计语言中 ， 使用构造器 （ constructor ) 构造新实例。 构造器是一种特殊的方法，用来构造并初始化对象。

构造器的名字应该与类名相同。

 通常 ，希望构造的对象可以多次使用 ， 因此，需要将对象存放在一个变量中：

```java
Date birthday = new Date();
```

在对象与对象变量之间存在着重要的区别。一定要认识到 ： 一个对象变量并没有实际包含一个对象， 而仅仅引用一个对象 。

在 Java 中， 任何对象变量的值都是对存储在另外一个地方的一个对象的引用 。 new 操作符的返回值也是一个引用。

可以显式地将对象变量设置为 null， 表明这个对象变量目前没有引用任何对象 。

### 用户自定义类

现在开始学习如何设计复杂应用程序所需要的各种主力类 （ workhorse class ) 。

在 Java 中 ， 最简单的类定义形式为 ：

```java
class ClassName
{
	field1
    field2
	constructor1
	constructor2
	method1
	method2
}
```

在一个源文件中，只能有一个公有类， 但可以有任意数目的非公有类。文件名必须与 public 类的名字相匹配。

#### 从构造器开始

- 构造器与类同名。

- 每个类可以有一个以上的构造器

- 构造器可以有0 个 、 1 个或多个参数

- 构造器没有返回值

- 构造器总是伴随着new 操作一起调用

#### 隐式参数与显式参数

方法用于操作对象以及存取它们的实例域。

```java
object.methodName(parameters);
```

`methodName`方法有两个参数。第一个参数称为隐式 （ implicit ) 参数 ， 是出现在方法名前的 object对象 。 第二个参数位于方法名后面括号中的数值， 这是一个显式（ explicit ) 参数。（ 有些人把隐式参数称为方法调用的目标或接收者。）

显式参数是明显地列在方法声明中的 ， 隐式参数没有出现在方法声明中。

在每一个方法中，关键字 this 表示隐式参数。

#### 封装的优点

在有些时候 ， 需要获得或设置实例域的值。 因此 ， 应该提供下面三项内容 ：

- 一个私有的数据域 ；
- 一个公有的域访问器方法 ；
- 一个公有的域更改器方法 。

这样做要比提供一个简单的公有数据域复杂些 ， 但是却有着下列明显的好处 ：

首先， 可以改变内部实现 ， 除了该类的方法之外 ， 不会影响其他代码 。

第二 ，更改器方法可以执行错误检查， 然而直接对域进行赋值将不会进行这些处理。

#### 基于类的访问权限

方法可以访问所调用对象的私有数据。一个方法还可以访问所属类的所有对象的私有数据，这令很多人感到奇怪
！

```java
class Employee
{
    public boolean equals ( Employee other )
	{
		return name.equals ( other.name ) ;
	}
}
```

#### 私有方法

在实现一个类时， 由于公有数据非常危险 ，所以应该将所有的数据域都设置为私有的 。然而， 方法又应该如何设计呢 ？尽管绝大多数方法都被设计为公有的，但在某些特殊情况下 ，也可能将它们设计为私有的。有时 ，可能希望将一个计算代码划分成若干个独立的辅助方法 。通常，这些辅助方法不应该成为公有接口的一部分 ，这是由于它们往往与当前的实现机制非常紧密 ，或者需要一个特别的协议以及一个特别的调用次序 。最好将这样的方法设计为 private 的 。

在 Java 中，为了实现一个私有的方法 ，只需将关键字 public 改为 private 即可。

对于私有方法 ， 如果改用其他方法实现相应的操作 ，则不必保留原有的方法 。如果数据的表达方式发生了变化
，这个方法可能会变得难以实现 ，或者不再需要。然而 ，只要方法是私有的，类的设计者就可以确信 ：它不会被外部的其他类操作调用 ，可以将其删去 。如果方法是公有的 ，就不能将其删去，因为其他的代码很可能依赖它。

#### final 实例域

可以将实例域定义为 final。 构建对象时必须初始化这样的域。也就是说 ，必须确保在每一个构造器执行之后 ，这个域的值被设置 ， 并且在后面的操作中，不能够再对它进行修改。

final 修饰符大都应用于基本 （ primitive ) 类型域，或不可变 （ immutable )类的域（ 如果类中的每个方法都不会改变其对象 ， 这种类就是不可变的类。 例如 ，String 类就是一个不可变的类）。

对于可变的类，使用 final 修饰符可能会对读者造成混乱，final 关键字只是表示存储在变量中的对象引用不会再指示其他对象，不过这个对象的域可以更改。

### 静态域与静态方法

#### 静态域

如果将域定义为 static , 每个类中只有一个这样的域。 而每一个对象对于所有的实例域却都有自己的一份拷贝。静态域属于类，不属于任何独立的对象。（区别类和对象，类是对象的模板）。

#### 静态常量

静态变量使用得比较少， 但静态常量却使用得比较多, 常量是final域。

例如，`Math.PI`.另一个多次使用的静态常量是 `System.out`。 它在 System 类中声明 ：

```java
public class System
{
	public static final PrintStream out = . . . ;
J
```

#### 静态方法

静态方法是一种不能向对象实施操作的方法。换句话说，静态方法没有隐式参数。

可以认为静态方法是没有this参数的方法（在一个非静态的方法中，this参数表示这个方法的隐式参数）。

静态方法不能访问自身类的实例域，因为它不能操作对象。但是静态方法可以访问自身类中的静态域。

可以使用对象调用静态方法。但是建议使用类名，而不是对象来调用静态方法。

在下面两种情况下使用静态方法：

- 一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（例如，`Math.pow`）。

- 一个方法只需要访问类的静态域。

#### 工厂方法

静态方法还有另外一种常见的用途。使用静态工厂方法（factory method）来构造对象。

使用静态工厂方法构造对象的好处：

- 单例模式的一种实现方式（静态域，静态工厂方法，枚举）
- 可以使用静态工厂方法的名称可以区别返回的对象作用（`java.util.concurrent.Executors.class`)
- 静态工厂方法可以返回方法声明返回类型的子类。

#### main 方法

 main 方法是一个静态方法。

main 方法不对任何对象进行操作 。事实上， 在启动程序时还没有任何一个对象 。 静态的main 方法将执行并创建程序所需要的对象 。

 每一个类可以有一个 main 方法。 这是一个常用于对类进行单元测试的技巧。

### 方法参数

按值调用 （ call by value ) 表示方法接收的是调用者提供的值。 而按引用调用（ call by reference )表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值 ， 而不能修改传递值调用所对应的变量值。按 … … 调用 ” ( call by ) 是一个标准的计算机科学术语，它用来描述各种程序设计语言 （ 不只是 Java ) 中方法参数的传递方式。

Java 总是采用按值调用。也就是说 ，方法得到的是所传**参数的值**的一个拷贝（基本类型的值得拷贝，或对象引用类型的对象引用的拷贝），特别是，方法不能修改传递给它的任何参数变量的内容（不能修改基本类型参数的值，也不能修改对象引用类型所引用的对象）。

有些程序员（甚至本书的作者）认为 Java程序设计语言对对象采用的是引用调用，实际上 ，这种理解是不对的。

面总结一下 Java 中方法参数的使用情况：

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。

- 一个方法可以改变一个对象参数的状态 。

- 一个方法不能让对象参数引用一个新的对象。

### 对象构造

前面已经学习了编写简单的构造器可以定义对象的初始状态。但是，由于对象构造非常重要，所以Java 提供了多种编写构造器的机制。

#### 重载

有些类有多个构造器。这种特征叫做重载（overloading）。如果多个方法有相同的名字、不同的参数，便产生了重载。

Java 允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（ signature )。返回类型不是方法签名的一部分。

#### 默认域初始化

如果在构造器中没有显式地给域赋予初值 ，那么就会被自动地赋为默认值 ：数值为 0 、布尔值为 false、对象引用为 null 。然而，只有缺少程序设计经验的人才会这样做 。如果不明确地对域进行初始化，就会影响程序代码的可读性 。（并非没有初始化，只是采用了默认值来进行初始化）

#### 无参数的构造器

很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态应当设置为适当的默认值。

如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。如果提供了一个有参数的构造器，系统不会再提供一个无参数构造器。

#### 显式域初始化

可以在类定义中 ，直接将一个值赋给域。在执行构造器之前，先执行赋值操作。 当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。初始值不一定是常量值。可以调用方法对域进行初始化。

```java
class Employee{
    private String name = ""
	private static int nextld ;
	private int id = assignld() ；
	private static int assignld(){
		int r = nextld;
		nextld ++;
        return r;
    }   
}
```

#### 参数名

参数变量用同样的名字将实例域屏蔽起来。this 指示隐式参数 ，也就是所构造的对象。

```java
public Employee ( String name , double salary)
{
	this.name = name;
	this,sal ary = salary;
}
```

#### 调用另一个构造器

关键字 this 引用方法的隐式参数。然而 ，这个关键字还有另外一个含义 。

如果构造器的第一个语句形如 this ( . . . )，这个构造器将调用同一个类的另一个构造器 。

采用这种方式使用 this 关键字非常有用， 这样对公共的构造器代码部分只编写一次即可。

#### 初始化块

前面已经讲过两种初始化数据域的方法：

- 在构造器中设置值

- 在声明中赋值

实际上，Java 还有第三种机制 ，称为初始化块（ initialization block ) 。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。 例如，

```java
class Employee
{
	private static int nextld ;
	private int id ;
	private String name ;
	private double salary ;
	// object initialization block
	{
    	id = nextld;
    	nextld ++;
    }
    ...
}
```

在这个示例中，无论使用哪个构造器构造对象，id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。

这种机制不是必需的，也不常见 。通常会直接将初始化代码放在构造器中 。

由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体处理步骤：

1. 所有数据域被初始化为默认值 （ 0、 false 或null )。
2. 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。

可以通过提供一个初始化值，或者使用一个静态的初始化块来对静态域进行初始化。

如果对类的静态域进行初始化的代码比较复杂， 那么可以使用**静态的初始化块**。

将代码放在一个块中， 并标记关键字 **static**。

```java
static{
	Random generator = new Random 0 ；
	nextld = generator . nextlnt ( lOOOO ) ;
}
```

在类第一次加载的时候 ， 将会进行静态域的初始化。所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行 。

### 包

从编译器的角度来看 ， 嵌套的包之间没有任何关系。 例如 ， `java.util` 包与 `java.util.jar` 包毫无关系。每一个都拥有独立的类集合 。

#### 类的导入

可以使用 import 语句导人一个特定的类或者整个包。例如，可以使用下面这条语句导人 `java.util`包中所有的类。

```java
import java.util.*;
```

#### 静态导入

import 语句不仅可以导人类 ， 还增加了导人静态方法和静态域的功能.

例如， 如果在源文件的顶部 ， 添加一条指令 ：

```java
import static java.lang.System.*;
```

就可以使用 System 类的静态方法和静态域，而不必加类名前缀:

```java
out.println( " Goodbye,World !"); //i.e.,System.out
```

但这种编写形式不利于代码的清晰度。