## 第三章 对象的共享

我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性或者确定 “ 临界区 ( Critical Section) ”。同步还有另一个重要的方面：内存可见性 ( Memory Visibility) 。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来保证对象被安全地发布。

### 3.1 可见性

可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。在单线程环境中，如果向某个变量先写入值，然后在没有其他写入操作的情况下读取这个变量，那么总能得到相同的值，这看起来很自然。然而，当读操作和写操作在不同的线程中执行时，情况却并非如此，这听起来或许有些难以接受。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

> 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

这听起来有点恐怖，但实际情况也确实如此。幸运的是，有一种简单的方法能避免这些复杂的问题：只要有数据在多个线程之间共享，就使用正确的同步。

#### 3.1.1 失效数据

在缺乏同步的程序中可能产生错误结果的一种情況：失效数据。当读线程査看 ready 变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。

仅对 set 方法进行同步是不够的，调用 get 的线程仍然会看见失效值。

#### 3.1.2 非原子的64位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-airsafety）。

最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量（double 和 long,请参见 3.1.4 节）。 Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量， JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。 当读取一个非 volatile 类型的long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的髙 32 位和另一个值的低 32 位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的 long 和 double 等类型的变量也是不安全的，除非用关键字 volatile 来声明它们，或者用锁保护起来。

#### 3.1.3 加锁和可见性

内置锁可以用于确保某个线程以一种可预测的方式来査看另一个线程的执行结果。当线程 A 执行某个同步代码块时，线程 B 随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁后同样可以由 B 看到 。如果没有同步，那么就无法实现上述保证。

现在，我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。

> 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### 3.1.4 Volatile 变量

Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。

volatile 变量对可见性的影响比 volatile 变量本身更为重要 。当线程 A 首先写入一个 volatile 变量并且线程 B 随后读取该变量时，在写入 volatile 变量之前对 A 可见的所有变量的值，在 B 读取了 volatile 变量后，对 B 也是可见的。然而，我们并不建议过度依赖 volatile 变量提供的可见性。如果在代码中依赖 volatile 变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。

> 加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。

当且仅当满足以下所有条件时，才应该使用 volatile 变量： -
• 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
• 该变量不会与其他状态变量一起纳入不变性条件中。
• 在访问变量时不需要加锁。

### 3.2 发布与逸出

“ 发布 (Publish)" 一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。当某个不应该发布的对象被发布时，这种情况就被称为逸出 ( Escape) 。

**现在，我们首先来看看一个对象是如何逸出的。**

- 发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。
- 当发布某个对象时，可能会间接地发布其他对象。
- 当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。
- 同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。
- 当把一个对象传递给某个外部方法时，就相当于发布了这个对象 。对于 C 来说，“ 外部（ Alien ）方法 ”是指行为并不完全由 C 来规定的方法，包括其他类中定义的方法以及类 C 中可以被改写的方法（public 或 protected）。
- 最后一种发布对象或其内部状态的机制就是发布一个内部类的实例。

**安全的对象构造过程**

> 不要在构造过程中使this引用溢出。

在构造过程中使 this 引用逸出的一个常见错误是，在构造函数中启动一个线程 。

在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致 this 引用在构造过程中逸出。

### 3.3 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement）,它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

在 Java 语言中并没有强制规定某个变量必须由锁来保护，同样在 Java 语言中也无法强制将对象封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素，必须在程序中实现。Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal 类，但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。

#### 3.3.1 Ad-hoc 线程封闭

Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担 。Ad-hoc 线程封闭是非常脆弱的，因为没有利用一种语言特性，将对象封闭到目标线程上。事实上，对线程封闭对象的引用通常保存在公有变量中。

在 volatile 变量上存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全地在这些共享的 volatile 变量上执行“ 读取-修改-写入 ” 的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且 volatile 变量的可见性保证还确保了其他线程能看到最新的值。

由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术(例如，栈封闭或 ThreadLocal 类) 。

#### 3.3.2 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈 。 栈封闭比 Ad-hoc 线程封闭更易于维护，也更加健壮。

对于基本类型的局部变量，无论如何都不会破坏栈封闭性。在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被引用的对象不会逸出。如果在线程内部 ( Within-Thread) 上下文中使用非线程安全的对象，那么该对象仍然是线程安全的。

#### 3.3.3 ThreadLocal 类

维持线程封闭性的一种更规范方法是使用 ThreadLocal, 这个类能使线程中的某个值与保存值的对象关联起来 。 ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。

ThreadLocal 对象通常用于防止对可变的单实例变量 (Singleton) 或全局变量进行共享。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接。

当某个线程初次调用 ThreadLocal.get 方法时 ， 就会调用 initialValue 来获取初始值。从概念上看，你可以将 ThreadLocal<T> 视为包含了 Map< Thread,T> 对象，其中保存了特定于该线程的值，但 ThreadLocal 的实现并非如此。这些特定于线程的值保存在 Thread 对象中，当线程终止后，这些值会作为垃圾回收。

在实现应用程序框架时大量使用了 ThreadLocal 。

### 3.4 不变性

满足同步需求的另一种方法是使用不可变对象（ Immutable Object ）。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。

> 不可变对象一定是线程安全的。

不可变对象很简单。它们只有一种状态，并且该状态由构造函数来控制。在程序设计中，一个最困难的地方就是判断复杂对象的可能状态。然而，判断不可变对象的状态却很简单。

同样，不可变对象也更加安全。不可变对象不会像被意代码或者有问题的代码破坏，因此可以安全地共享和发布这些对象，而无须创建保护性的副本。

虽然在 Java 语言规范和 Java 内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为 final 类型，即使对象中所有的域都是 final 类型的，这个对象也仍然是可变的，因为在 final 类型的域中可以保存对可变对象的引用。

> 当满足以下条件时，对象才是不可变的：
> •对象创建后其状态就不能修改。
> •对象的final域都是final类型。
> •对象是正确创建的（ 在对象的创建期间，this 引用没有逸出）。

在 “ 不可变的对象 ” 与 “ 不可变的对象引用 ” 之间存在着差异。保存在不可变对象中的程序状态仍然可以更新，即通过用一个保存新状态的实例来 “ 替换 ” 原有的不可变对象。

**3.4.1 Final 域**

关键字 final  用于构造不可变性对象。final类型的域是不能修改的（但如果 final 域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。然而，在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

> 正如"除非需要更高的可见性，否则应将所有的域都声明位私有域"是一个良好的编程习惯，”除非需要某个域是可变的，否则应将其声明为 final 域“ 也是一个良好的编程习惯。

**3.4.2 示例 ： 使用 Volatile 类型来发布不可变对象**

对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。通过使用包含多个状态变量的容器对象来维持不变性条件，并使用一个 volatile 类型的引用来确保可见性。

### 3.5 安全发布

某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。

**3.5.1 不正确的发布：正确的对象被破坏**

如果没有足够的同步，那么当在多个线程间共享数据时将发生一些非常奇怪的事情。

**3.5.2 不可变对象与初始化安全性**

由于不可变对象是一种非常重要的对象，因此 Java 内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致的视图，就必须使用同步。

另一方面，即使在发布不可变对象的引用时没有使用同步，也仍然可以安全地访问该对象。为了维持这种初始化安全性的保证，必须满足不可变性的所有需求：状态不可修改，所有域都是 final 类型，以及正确的构造过程。

> 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。

这种保证还将延伸到被正确创建对象中所有 final 类型的域。在没有额外同步的情况下，也可以安全地访问 final 类型的域。然而，如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。

**3.5.3 安全发布的常用模式**

可变对象必须通过安全的方式来发布，这通常意味着线程在发布和使用该对象时都必须使用同步。现在，我们将重点介绍如何确保使用对象的线程能够看到该对象处于已发布的状态，并稍后介绍如何在对象发布后对其可见性进行修改。

> 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象必须通过以下方式来安全的发布：
>
> - 在静态初始化函数中初始化一个对象引用。
> - 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中。
> - 将对象的引用保存到某个正确构造对象的 final 类型域中。
> - 将对象的引用保存到一个由锁保护的域中。

在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如 Victor 或 synchronizedList 时，将满足上述最后一条需求。尽管 Javadoc 在这个主题上没有给出很清晰的说明，但线程安全库中的容器类提供了以下的安全发布保证：

- 通过将一个键或者值放入 Hashtable、synchronizedMap 或者 ConcurrentMap 中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。
- 通过将某个元素放入 Vector、CopyOnWriteArrayList 、 CopyOnWriteArraySet 、 synchronizedList
  或 synchronizedSet 中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
- 通过将某个元素放入 BlockingQueue 或者 ConcurrentLinkedQueue 中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。

类库中的其他数据传递机制（ 例如 Future 和 Exchanger ）同样能实现安全发布，在介绍这些机制时将讨论它们的安全发布功能。

通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：

```java
public static Holder holder = new Holder(42);
```

静态初始化器由 JVM 在类的初始化阶段执行。由于在 JVM 内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。

**3.5.4 事实不可变对象**

如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的，并且如果对象状态不会再改变，那么就足以确保任何访问都是安全的。

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“ 事实不可变对象(Effectively Immutable Object) 这些对象不需要满足 3.4 节中提出的不可变性的严格定义。在这些对象发布后，程序只需将它们视为不可变对象即可。通过使用事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。

> 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

**3.5.5 可变对象**

如果对象在构造后可以修改，那么安全发布只能确保 “ 发布当时 ” 状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的或者由某个锁保护起来。

> 对象的发布需求取决于它的可变性：
>
> - 不可变对象可以通过任意机制来发布。
> - 事实不可变对象必须通过安全方式来发布。
>
> - 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

**3.5.6 安全地共享对象**

当获得对象的一个引用时，你需要知道在这个引用上讨以执行哪些操作。在使用它之前是否需要获得一个锁？是否可以修改它的状态，或者只能读取它？许多并发错误都是由于没有理解共享对象的这些 “ 既定规则 ” 而导致的。当发布一个对象时，必须明确地说明对象的访问方式。

> 在并发程序中使用合共享对象时，可以使用一些适用的策略，包括：
>
> **线程封闭**。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
>
> **只读共享**。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，任何线程都不能修改它。共享的只对对象包括不可变对象和事实不可变对象。
>
> **线程安全共享**。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。
>
> **保护对象**。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

