# 结构型模式：适配器，桥接，组合

## 结构型模式：

结构型模式（Structural Pattern）描述如何将类或者对象结合在一起形成更大的结构。

结构型模式可以描述两种不同的东西，类与类的实例（即对象）。根据这一点，结构型模式可以分为类结构型模式和对象结构型模式。

类结构型模式关心类的组合，由多个类可以组成一个更大的系统，在类结构型模式中一般只存在**继承关系**和**实现关系**。

对象结构型模式关系类与对象的组合，通过**关联关系**使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。

## 适配器模式

**适配器模式（Adapter Pattern）定义：**

将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的类可以一起工作，其别名为包装器（Wrapper）。适配器模式即可作为类结构型模式，也可以作为对象结构型模式。

英文定义：Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

**适配器模式结构：**

适配器模式包括类适配器和对象适配器，下面分别对两种适配器进行结构分析。

适配器包含如下角色：

1. Target(目标抽象类)

目标抽象类定义客户要用的特定领域的接口。

2. Adapter（适配器类）

适配器类可以调用另一个接口，作为一个转换器，对Adapter和Target进行适配。适配器Adapter是适配器模式的核心。在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系；在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。

3. Adaptee（适配者类）

适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配。适配者类一般是一个具体类，这个类定义了客户希望使用的业务接口，在某些情况下甚至没有适配者类的源代码。

4. Client（客户类）

在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。

**适配器模式扩展：**

缺省适配器模式（Default Adapter Pattern）的定义：当不需要实现接口提供的全部方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择地覆盖方法来实现需求。它适用于一个接口不想使用其所有方法的情况。

在缺省适配器模式中，包含三个角色：适配者接口、缺省适配器类、具体业务类。

**小结：**

（1）适配器模式更多的是强调对代码的组织，而不是功能的实现。

（2）与类适配者模式相比，对象适配者模式想要置换适配者类的方法就不容易。

## 桥接模式

**桥接模式（Bridge）定义：**

将抽象部分与它的实现部分分离，是他们都可以独立的变化。它是一种对象结构型模式，又称为柄体模式（Handle and Body)或接口模式（Interface）。

英文定义: Decouple an abstraction from its implementation so that the two can vary independently.

**动机：**

当一个抽象可能有多个实现时，通常用继承来协调他们。抽象类定义对该抽象的接口，而具体的子类则用不同的方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。

**桥接模式结构：**

桥接模式包含如下角色：

1. Abstraction（抽象类）

用于定义抽象类的接口，它一般是抽象类而不是接口。维护一个Implementor 类型的对象引用。可以包含抽线的业务方法和具体的业务方法。

2. RefinedAbstraction（扩充抽象类）

扩充由 Abstraction 定义的接口。

3. Implementor（实现类接口）

定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用 Implementor 中定义的方法，使用关联关系来替代继承关系。

4. ConcreteImplementor（具体实现类）

实现 Implementor 接口并定义它的具体实现。

**协作：**

Abstraction将client的请求转发给它的Implementor对象。

在抽象类 Abstraction 中定义了一个实现类接口的成员变量impl，再通过注入的方式给该对象赋值，一般该对象的可见性定义为 protected，以便在其之类中访问 Implementor 的方法。

**模式分析：**

理解桥接模式，重点是要理解如何将抽象化（Abstraction）和实现化（Implementation）脱耦，使得二者可以独立的变化。这里面包含了3个关键词，分别是抽象化、实现化和脱耦。

1. 抽象化

抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面像对象中，将对象的共同性质抽取出来形成类的过程就是抽象化的过程。

2. 实现化

针对抽象化给出的具体实现，就是实现化。抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是抽象化事物进一步具体化的产物。

3. 脱耦

脱耦就是将抽象化和实现化之间的耦合解脱开，或者说将它们间的强关联改成弱关联，将两个角色之间的继承关系改成关联关系。桥接模式中所谓的脱耦，就是指在一个软件的抽象化和实现化之间使用关联关系（组合或聚合关系）而不是继承关系，从而使两者可以相对独立的变化，这就是桥接模式的用意。

**适用性：**

以下情况使用Bridge模式：

- 你不希望在抽象和它的实现之间有一个固定的绑定关系。可能是因为，在程序运行时刻实现部分应可以被选择或切换。
- 类的抽象以及它的实现都因该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。
- 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。
- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**实现：**



**效果：**



**相关模式：**