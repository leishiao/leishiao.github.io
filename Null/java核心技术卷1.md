java核心技术卷1

第五章 继承

利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。

反射是指在程序运行期间发现更多类及其属性的能力。

子类比超类封装了更多的数据，拥有更多功能

在通过扩展超类定义子类的时候 ， 仅需要指出子类与超类的不同之处 。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中 ，这种将通用的功能放到超类的做法，在面向对象程序设计中十分普遍 。

有些人认为 super 与 this 引用是类似的概念 ， 实际上 ， 这样比较并不太恰当 。 这是因为 super 不是一个对象的引用 ， 不能将 super 赋给另一个对象变量，它只是一个**指示编译器调用超类方法的特殊关键字**。

在子类中可以**增加域**，**增加方法**，**覆盖超类方法**，然而不能删除继承的任何域和方法

由于子类的构造器不能访问父类的私有域 ， 所以必须利用父类的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用 。 使用super 调用构造器的语句必须是子类构造器的第一条语句 。

回忆一下 ， 关键字 this 有两个用途 ： 一是引用隐式参数 ， 二是调用该类其他的构造器，同样，super关键字也有两个用途 ： 一是调用超类的方法， 二是调用超类的构造器 。在调用构造器的时候 ， 这两个关键字的使用方式很相似 。 调用构造器的语句只能作为另一个构造器的第一条语句出现 。 构造参数既可以传递给本类 （ this ) 的其他构造器 ， 也可以传递给超类 （ super ) 的构造器 。

一个对象变量 （ 例如， 变量 e )可以指示多种实际类型的现象被称为**多态** （ polymorphism )。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定** （ dynamic binding )。

在覆盖方法时 ，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。

如果是 private 方法 、 static 方法 、 final 方法  或者构造器 ， 那么编译器将可以准确地知道应该调用哪个方法， 我们将这种调用方式称为静态绑定 （ static binding ) 。

 我们提倡在设计类层次时，仔细地思考应该将哪些方法和类声明为 final。

如果一个方法没有被覆盖并且很短 ， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。 例如 ，内联调用 e . getName ( ) 将被替换为访问 e . name 域 。

不允许扩展的类被称为 final类。 如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。

在有些时候 ， 人们希望超类中的某些方法允许被子类访问 ，或允许子类的方法访问超类的某个域。 为此 ， 需要将这些方法或域声明为 protected 。

下面归纳一下 Java 用于控制可见性的 4 个访问修饰符 ：
1 ) 仅对本类可见 private。
2 ) 对所有类可见 public 。
3 ) 对本包和所有子类可见 protected。
4 ) 对本包可见 — 默认 （ 很遗憾 ) ，不需要修饰符

枚举类声明定义的类型是一个类 ， 它刚好有有限个实例，可以在枚举类型中添加一些构造器 、 方法和域 。构造器只是在构造枚举常量的时候被调用。

```java
public enum Size
{
	SMALLfS " ) , MEDIUMC ' M " ) , LARGEfL " ) , EXTRA _ LARGE ( " XL " ) ;
	private String abbreviation ;
	private Size ( St ring abbreviation ) { this , abbreviation = abbreviation ; }
	public String getAbbreviation () { return abbreviation ; }
}
```

在程序运行期间， Java 运行时系统始终为所有的对象维护一个被称为**运行时的类型标识** 。这个信息跟踪着每个对象所属的类 。 虚拟机**利用运行时类型信息选择相应的方法执行** 。然而 ， 可以通过专门的 Java 类访问这些信息 ，保存这些信息的类被称为 Class ,这 个 名字很容易让人混淆 。 Object 类中的 getClass ( ) 方法将会返回一个 Class 类型的实例 。 一个Class 对象将表示一个特定类的属性。

 整型数组类型 int [] 可以被转换成 Object， 但不能转换成对象数组 。



 protected 方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用 。





## 第 6 章 接 口、lambda 表达式与内部类

首先， 介绍一下接口 （ interface )技术， 这种技术主要用来描述类具有什么功能 ， 而并不给出每个功能的具体实现。 一个类可以实现 （ implement )—个或多个接口， 并在需要接口的地方， 随时使用实现了相应接口的对象。

在 Java 程序设计语言中 ， 接口不是类， 而是对类的一组需求描述 ， 这些类要遵从接口描述的统一格式进行定义。

接口中的所有方法自动地属于 public。 因此 ， 在接口中声明方法时 ， 不必提供关键字public。

在接口中还可以定义常常量。

接口不是类，尤其不能使用 new 运算符实例化一个接口 。

尽管不能构造接口的对象 ， 却能声明接口的变量，接口变量必须引用用实现了接口的类对象 。

如同使用 instanceof 检查一个对象是否属于某个特定类一样 ， 也可以使用instance 检查一个对象是否实现了某个特定的接口。

与可以建立类的继承关系一样， 接口也可以被扩展 。 这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。

有些接口只定义了常量 ， 而没有定义方法。任何实现该接口的类都自动地继承了这些常量 ， 并可以在方法中直接地引用 NORTH 。

