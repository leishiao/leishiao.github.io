## 第二章 线程安全性

要编写线程安全的代码，其核心在于要对状态访问操作进行管理 ，特别是对共享的（ Shared ） 和可变的（Mutable ） 状态的访问 。

从非正式的意义上来说 ， 对象的状态是指存储在状态变量 （ 例如实例或静态域 ） 中的数据 。 对象的状态可能包括其他依赖对象的域 。 在对象的状态中包含了任何可能影响其外部可见行为的数据 。

 共享 ” 意味着变量可以由多个线程同时访问 ， 而 “ 可变 ” 则意味着变量的值在其生命周期内可以发生变化 。

一个对象是否需要是线程安全的 ， 取决于它是否被多个线程访问 。 

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时 ， 必须采用同步机制来协同这些线程对变量的访问 。

> 如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
>
> - 不在线程之间共享该状态变量
> - 将状态变量修改为不可变的变量
> - 在访问状态变量时使用同步

在一些大型程序中 ， 要找出多个线程在哪些位置上将访问同一个变量是非常复杂的 。 幸运的是 ，面向对象这种技术不仅有助于编写出结构优雅 、 可维护性高的类 ， 还有助于编写出线程安全的类 。访问某个变量的代码越少，就越容易确保对变量的所有访问都实现正确同步 ，同时也更容易找出变量在哪些条件下被访问 。 Java 语言并没有强制要求将状态都封装在类中，开发人员完全可以将状态保存在某个公开的域（ 甚至公开的静态域 ）中，或者提供一个对内部对象的公开引用 。 然而 ，程序状态的封装性越好， 就越容易实现程序的线程安全性，并且代码的维护人员也越容易保持这种方式 。

> 当设计线程安全的类时，良好的面向对象技术 、不可修改性,以及明晰的不变性规范都能起到一定的帮助作用。

有时候 ， 面向对象中的抽象和封装会降低程序的性能（ 尽管很少有开发人员相信 ），但在编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度。

“线程安全类” 和 “ 线程安全程序 ” 这两个术语 的含义基本相同 。 线程安全的程序是否完全由线程安全类构成 ？ 答案是否定的 ， 完全由线程安全类构成的程序并不一定就是线程安全的 ， 而在线程安全类中也可以包含非线程安全的类 。

### 2.1 什么是线程安全性

在线程安全性的定义中 ， 最核心的概念就是正确性 。 如果对线程安全性的定义是模糊的 ，那么就是因为缺乏对正确性的清晰定义 。

正确性的含义是，某个类的行为与其规范完全一致。 在良好的规范中通常会定义各种不变性条件 (Invariant) 来约束对象的状态，以及定义各种后验条件 (Postcondition) 来描述对象操作的结果 。 由于我们通常不会为类编写细的规范 ， 那么如何知道这些类是否正确呢 ？ 我们无法知道，但这并不妨碍我们在确信 “ 类的代码能工作 ” 后使用它们。 这种 “ 代码可信性 ” 非常接近于我们对正确性的理解，因此我们可以将单线程的正确性近似定义为 “ 所见即所知 ( we know it when we see it) ”。

对 “ 正确性 ” 给出了一个较为清晰的定义后，就可以定义线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

如果正确地实现了某个对象，那么在任何操作中(包括调用对象的公有方法或者对其公有域进行读 / 写操作)都不会违背不变性条件或后验条件。在线程安全类的对象实例上执行的任何串行或并行操作都不会使对象处于无效状态。

> 在线程安全类中封装了必要的同步机制，因此客户端无须进一歩采取同步措施。

无状态对象一定是线程表全确的。

> 由于线程访问无状态对象的行为井不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。

### 2.2 原子性

在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字 ： 竞态条件 ( Race Condition )。

#### 2.2.1 竟态条件

当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气。

最常见的竞态条件类型就是 “ 先检査后执行 （ Cheek-Then-Act ） ” 操作，即通过一个可能失效的观测结果来决定下一步的动作。

#### 2.2.2 示例：延迟初始化中的竞态条件

使用 “ 先检査后执行 ” 的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次（例如单例模式中的懒汉模式，不推荐)。

另一种竟态条件。在 “ 读取-修改-写入” 这种操作（ 例如递增一个计数器 ）中，基于对象之前的状态来定义对象状态的转换。要递增一个计数器，你必须知道它之前的值，并确保在执行更新的过程中没有其他线程会修改或使用这个值。

#### 2.2.3 复合操作

要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。

> 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作（或者说不可分割的操作）。

为了确保线程安全性，“先检查后执行” (例如延迟初始化)和 “读取-修改-写入” (例如递增运算)等操作必须是原子的。我们将 “ 先检査后执行 ” 以及 “读取-修改-写入” 等操作统称为复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。加锁机制是 Java 中用于确保原子性的内置机制。

我们在因数分解的 Servlet 中增加了一个计数器 ， 并通过使用线程安全类 AtomicLong 来管理计数器的状态，从而确保了代码的线程安全性。当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。然而，当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单。

> 在实际情况中，应尽可能地使用现有的线程安全对象(例如 AtomicLong) 来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况更为容易 ， 从而也更容易维护和验证线程安全性。

### 2.3 加锁机制

当在 Servlet 中添加一个状态变量时，可以通过线程安全的对象来管理 Servlet 的状态以维护 Servlet 的线程安全性。但如果想在 Servlet 中添加更多的状态，那么是否只需添加更多的线程安全状态变量就足够了？

在线程安全性的定义中要求，多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。当在不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

> 要保持状态的致性，就需要在单个原子操作中更新所有相关的状态变量。

#### 2.3.1 内置锁

Java 提供了一种内置的锁机制来支持原子性:  同步代码块 (Synchronized Block) 。（第3章将介绍加锁机制以及其他同步机制的另一个重要方面：可见性）同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的 synchronized 方法以 Class 对象作为锁。

```java
synchronized (lock) {
// 访问或修改由锁保护的共享状态
}
```

每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁 (Intrinsic Lock) 或监视器锁 (Monitor Lock) 。 线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java 的内置锁相当于一种互斥体(或互斥锁)，这意味着最多只有一个线程能持有这种锁。当线程 A 尝试获取一个由线程 B 持有的锁时，线程 A 必须等待或者阻塞，直到线程 B 释放这个锁。如果 B 永远不释放锁，那么 A 也将永远地等下去 。

由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块时也不会相互干扰。并发环境中的原子性与事务应用程序中的原子性有着相同的含义——一组语句作为一个不可分割的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其他线程正在执行由同一个锁保护的同步代码块。

#### 2.3.2 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。”重入“意味着获取锁的操作的粒度是“线程 ”，而不是“ 调用 ”。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为 0 时，这个锁将被释放。

重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。

### 2.4 用锁来保护状态

由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。 只要始终遵循这些协议，就能确保状态的一致性。

访问共享状态的复合操作，例如命中计数器的递增操作（读取-修改-写入）或者延迟初始化（先检查后执行），都必须是原子操作以避免产生竞态条件。如果在复合操作的执行过程中持有一个锁，那么会使复合操作成为原子操作。然而，仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。

一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此。

> 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

对象的内置锁与其状态之间没有内在的关联。虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。你需要自行构造加锁协议或者同步策略来实现对共享状态的安全访问，并且在程序中自始至终地使用它们。

> 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。在许多线程安全类中都使用了这种模式，例如 Vector 和其他的同步集合类。在这种情况下，对象状态中的所有变量都由对象的内置锁保护起来 。然而，这种模式并没有任何特殊之处，编译器或运行时都不会强制实施这种（或者其他的）模式如果在添加新的方法或代码路径时忘记了使用同步，那么这种加锁协议会很容易被破坏。

并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

当某个变量由锁来保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量。当类的不变性条件涉及多个状态变量时，那么还有另外一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。因此可以在单个原子操作中访问或更新这些变量，从而确保不变性条件不被破坏。

> 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

如果同步可以避免竞态条件问题，那么为什么不在每个方法声明时都使用关键字synchronized ? 

- 事实上，如果不加区别地滥用 synchronized, 可能导致程序中出现过多的同步 。

- 此外，如果只是将每个方法都作为同步方法，例如 Vector，那么并不足以确保 Vector 上复合操作都是原子的：

  ```java
  if (!vector.contains(element))
  	vector.add(element);
  ```

  虽然 contains 和 add 等方法都是原子方法，但在上面这个 “ 如果不存在则添加 (put-if-absent) ” 的操作中仍然存在竞态条件。虽然 synchronized 方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制(请参见 4.4 节了解如何在线程安全对象中添加原子操作的方法) 。 

- 此外，将每个方法都作为同步方法还可能导致活跃性问题(Liveness) 或性能问题 (Performance)。

### 2.5 活跃性与性能

在 UnsafeCachingFactorizer 中，我们通过在因数分解 Servlet 中引入了缓存机制来提升性能。在缓存中需要使用共享状态，因此需要通过同步来维护状态的完整性。然而，如果使用 SynchronizedFactorizer 中的同步方式，那么代码的执行性能将非常糟糕。SynchronizedFactorizer 中采用的同步策略是，通过 Servlet 对象的内置锁来保护每一个状态变量，该策略的实现方式也就是对整个 service 方法进行同步。虽然这种简单且粗粒度的方法能确保线程安全性，但付出的代价却很高。

当多个请求同时到达因数分解 Servlet 时，这些请求将排队等待处理。我们将这种 Web 应用程序称之为不良并发(Poor Concurrency)应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。 幸运的是，通过缩小同步代码块的作用范围，我们很容易做到既确保 Servlet 的并发性 ， 同时又维护线程安全性。要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。 

对在单个变量上实现原子操作来说，原子变量是很有用的，但由于我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，也不会在性能或安全性上带来任何好处，因此在这里不使用原子变量。

要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须得到满足 ）、简单性和性能。有时候，在简单性与性能之间会发生冲突，但在二者之间通常能找到某种合理的平衡。

> 通常，在简单性与性能之间存在着相互制约的因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能会破环安全性）。

当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。

> 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O)，一定不要持有锁。 