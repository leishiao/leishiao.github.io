## 装饰模式

**装饰模式（Decorator Pattern）定义：**

动态的给一个对象增加一些额外的职责（Responsibility），就增加对象功能来说，装饰 模式比生成子类更为灵活。

英文定义：Attach additional responsibilities to an object dynamially. Decorators provide a flexible alternative to subclassing  for extending functionality.

其别名成为包装器（Wrapper），与适配器别名相同，但它们适用于不同的场合。

**动机**

有时我们希望给某个对象而不是整个类增加一些新功能。一般有两种方式给对象或类增加行为：

1. 继承机制
   使用继承机制是给现有类添加功能的一种有效途径。通过继承一个现有的类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方法和时机。
2. 关联机制
   关联机制是更加灵活的方法，即将一个类的对象嵌入另一个类的对象中，由另一个对象来决定是否调用嵌入对象的行为并扩展新的行为，我们称这个新的对象为装饰器（Decorator）。为了使得装饰器与它所装饰的对象对客户端透明，装饰器类和被装饰的类必须实现相同的接口，装饰器将请求转发给被装饰的对象，并且可能在转发的前后执行一些额外的动作。透明性使得可以嵌套多个装饰，从而可以添加任意多的功能。

**模式结构：**

装饰模式包含如下角色：

1. Component（抽象构件）
   定义一个对象接口，可以给这些对象动态的添加职责。抽象构件是具体构件和抽象装饰类的共同父类。
2. ConcreteComponent（具体构件）
   具体构件定义了具体的构件对象，实现了在抽象构件中声明的方法。
3. Decorator（抽象装饰类）
   抽象装饰类是抽象构件的子类，维护一个指向抽象构件对象的引用。
4. ConcreteDecorator（具体装饰类）
   具体装饰类是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用抽象装饰类中定义的方法，并可以增加新的方法一边扩充对象的行为。

**协作**

- Decorator 将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。

**适用性**

以下情况使用Decorator模式

- 在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责。
- 处理那些可以撤销的职责。
- 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一中情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

**效果**

（1）比静态继承更灵活	为一个特定的Component类提供多个不同的Decorator类，使得可以对一些职责进行混合的匹配。

**实现**

使用Decorator模式时应注意以下几点

（1）接口的一致性	装饰对象的接口必须与他所装饰的Component的接口是一致的，因此，所有的ConcreteDecorator必须有一个公共的父类。组件和装饰必须有一个公共的Component父类。

（2）改变对象外壳与改变对象内核	我们可以将Decorator看作一个对象的外壳，它可以改变这个对象的行为。另一种方法是改变对象的内核。Strategy模式就是一个用于改变内核的很好的模式。

**相关模式**

Adapter模式：Decorator模式不同于Adapter模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。
Composite模式：可以将装饰视为一个退化的、仅有一个组件的组合。然而装饰仅给对象添加一些额外的职责，他的目的不在于对象聚合。
Strategy模式：用一个装饰你可改变对象的外表；而strategy模式使得你可以改变对象的内核。这是改变对象的两种途径。