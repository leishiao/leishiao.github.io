# 创建型模式：简单工厂，工厂方法，抽象工厂



## 简单工厂模式

**简单工厂模式（Simple Factory Pattern）定义：**

简单工厂模式称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

**模式结构**

简单工厂模式包含如下角色：

1、Factory（工厂角色）

工厂角色即工厂类，负责实现创建所有实例的内部逻辑；在工厂类中提供了一个静态工厂方法，他返回一个抽象产品类，所有具体产品都是抽象产品的子类。

2、Product（抽象产品角色）

具体产品的父类

3、ConcreteProduct（具体产品角色）

抽象产品的子类

**简单工厂模式扩展**

1、把静态工厂方法写在抽象产品类中或接口中，从而去掉工厂类。

2、只有一个具体产品时，可以将静态工厂方法写在具体产品类中，从而去掉工厂类和抽象产品类。

3、不使用参数，而是定义多个静态工厂方法用于返回不同的对象。可与1、2点相结合来扩展。

**模式适用环境**

1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成静态工厂方法中的业务逻辑太过复杂。

2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端不需要关心创建细节，只需要知道类型所对应参数即可。

**小结：**

（1）创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。

（2）简单工厂模式称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

（3）简单工厂模式包含三个角色：工厂角色，抽象产品角色，具体产品角色。

（4）简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需的对象，而无需知道其创建细节。

（5）简单工厂模式最大的优点在于：实现对象的创建和使用分离，将对象的创建交给专门的工厂类负责。其最大的缺点在于：工厂类不够灵活，增加新的具体产品类需要修改静态工厂方法的逻辑判断代码，而且产品较多时，静态工厂方法代码将会非常复杂。

（6）简单工厂类适用情况包括：工厂类负责创建的对象比较少；客户端只需要知道工厂类的参数，对于如何创建对象不关心。

## 工厂方法模式

**工厂方法模式（Factory Method Pattern）定义：**

工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建抽象产品对象的公共接口，而工厂子类负责生成具体产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

英文定义：Define an interface for creating an object，but let subclasses decide which class to instantiate. Factory Method lets a class to defer instantiation to subclasses .

**模式结构**

工厂模式中包含如下角色：

1、Product（抽象产品）

抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的共同父类或接口。

2、ConcreteProduct（具体产品）

具体产品实现了具体产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间一一对应。

3、Factory（抽象工厂）

在抽象工厂类中，声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，它与应用程序无关。任何在模式中创建对象的工厂类都必须实现该接口。

4、ConcreteFactory（具体工厂）

具体工厂类是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，返回一个具体产品类的实例。

**工厂方法模式扩展**

1、使用多个工厂方法（都返回同一种抽象产品，抽象工厂模式可以返回不同种抽象产品）

在抽象工厂角色中可以定义多个工厂方法，让具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求。

2、产品对象的重复使用

工厂方法总是调用产品类的构造函数以创建一个新的产品实例，然后将这个实例返回个客户端。而在实际情况中，工厂方法做的事情可以相当复杂，一个常见的复杂逻辑就是重复使用产品对象。有则返回，无则创建。

3、多态性的丧失和模式的退化

- 工厂方法返回的类型应当是抽象类型，而不是具体类型。调用工厂方法的客户端应当依赖抽象工厂和抽象产品编程，而不是具体工厂和具体产品。
- 如果工厂方法返回一个具体产品对象，便违背了工厂方法的用意，发生退化此时就不再是工厂方法模式了。
- 一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个工厂类的话，抽象工厂就可以省略。
- 在一个类中使用实例工厂方法创建同一父类不同子类型的对象的情况不应该存在，可以重构为工厂方法模式或简单工厂模式。
- 在一个类中使用静态工厂方法创建同一父类不同子类型的对象的情况就是简单工厂模式。

**模式适用环境**

1、一个类不知道它所需要对象的类：在工厂方法模式中，具体的产品类由具体的工厂类创建，客户端只需要知道创建具体产品的工厂类。

2、一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏替换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更易扩展。（常见情况：调用工厂方法给自身成员变量赋值）

3、将创建对象的任务委托给多个工厂子类中的一个，客户端使用时无需关心哪一个工厂子类创建了哪一个产品子类，需要时再动态绑定，可将具体工厂类存储在配置文件中。

**小结：**

（1）工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建抽象产品对象的公共接口，而工厂子类负责生成具体产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

（2）工厂方法模式包含4个角色：抽象产品，具体产品，抽象工厂，具体工厂

（3）工厂方法模式是简单公共模式的进一步抽象和推广。由于使用了面向对象的多态性，公共方法模式保持了简单工厂模式的优点，克服了它的缺点。在工厂方法模式中，核心的工厂类不在负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。

（4）工厂方法模式的主要优点是增加新的产品类时无需修改现有系统，并封装了产品的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。

（5）工厂方法模式适用情况包括：一个类不知道它所需要对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的一个，客户端使用时无需关心哪一个工厂子类创建了哪一个产品子类，需要时再动态绑定。

## 抽象工厂模式

两个概念：

（1）产品等级结构：产品等级结构即产品的继承结构。

（2）产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。

抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式和工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。

**抽象工厂模式（Abstract Factory Patten）定义：**

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

英文定义：Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

**模式结构**

1、AbstractFactory（抽象工厂）

抽象工厂用于声明创建抽象产品的方法，在一个抽象工厂中可以定义一组方法，一个方法对应一个产品等级结构。

2、ConcreteFactory（具体工厂）

具体工厂实现了抽象工厂声明的创建抽象产品的方法，创建一组具体产品，这些产品构成一个产品族，每一个产品都位于某个产品等级结构中。

3、AbstractProduct（抽线产品）

抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。

4、ConcreteProduct（具体产品）

具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。

**抽象工厂模式扩展**

1、抽象工厂模式的退化

当抽象工厂模式中的每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。

**模式适用环境**

（1）一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都很重要。用户无需关心对象的创建过程，将对象的创建和使用解耦。

（2）系统中有多个产品族，而每次只能使用其中某一个产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便的增加产品族。

（3）属于同一个产品族中的对象将在一起使用，这一约束必须在系统的设计中体现出来。同一产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束。

（4）系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。对于这些产品，用户只需要知道它们提供了那些具体的业务方法，而不需要知道这些对象的创建过程，在客户端代码中针对抽象编程，而将具体类写入配置文件中。

**小结：**

（1）抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

（2）抽象工厂模式包含四个角色：抽象工厂，具体工厂，抽象产品，具体产品

（3）抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式和工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。

（4）抽象工厂模式的主要有点是隔离具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或替换产品族比较方便，增加新具体工厂和的产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有具体工厂类，对“开闭原则”的支持呈现倾斜性。

（5）抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多个产品族，而每次只能使用其中某一个产品族；属于同一个产品族中的对象将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。