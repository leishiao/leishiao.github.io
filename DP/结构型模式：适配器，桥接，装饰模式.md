# 结构型模式：适配器，桥接模式，装饰模式

## 结构型模式

结构型模式（Structural Pattern）描述如何将类或者对象结合在一起形成更大的结构。

结构型模式可以描述两种不同的东西，类与类的实例（即对象）。根据这一点，结构型模式可以分为类结构型模式和对象结构型模式。

类结构型模式关心类的组合，多个类可以组成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。

对象结构型模式关心类与对象的组合，使用关联关系，在一个类中定义另一个类的对象，然后调用该对象的方法。

## 适配器模式

**适配器模式（Adapter Pattern）定义：**

将一个类的接口转换成客户希望的另一个接口，适配器模式使接口不兼容的类可以一起工作。其别名为包装器（Wrapper）。适配器模式即可作为类结构型模式，也可以作为对象结构型模式。

英文定义：Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

**适用性：**

以下情况适用Adapter模式：

- 你想使用一个已经存在的类，而它的接口不符合你的需求。
- 你想创建一个可以复用的类，该类可以与不相关的类或不可预见的类协同工作
- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它们的父接口。（仅适用于对象Adapter）

**参与者：**

适配器模式包括类适配器模式和对象适配器模式，下面分别对两种适配器模式进行结构分析。

适配器模式包含如下角色：

- Target(目标抽象类)
  定义Client使用的特定领域的接口。
- Client（客户类）
  与符合Target接口的对象协同工作。
  在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。
- Adaptee（适配者类）
  它定义了一个已经存在的接口，这个接口需要适配。
  适配者类一般是一个具体类，这个类定义了客户希望使用的业务接口，在某些情况下甚至没有适配者类的源代码。
- Adapter（适配器类）
  对Adaptee的接口与Target接口进行适配。
  在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系；
  在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。

**协作：**

- Client在Adapter实例上调用一些操作。接着Adapter调用Adaptee的操作实现这个请求。

**效果：**

类适配器和对象适配器有不同的权衡。

类适配器

- 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是，当我们想要匹配一个类及它的子类时，类适配器将不能胜任工作。
- 使得Adapter可以重新定义Adaptee的行为，因为Adapter是Adaptee的一个子类。
- 仅仅引入一个对象，并不需要额外的引用以间接得到Adaptee。

对象适配器

- 允许一个Adapter与多个Adaptee（Adaptee本身以及他的所有子类）同时工作。Adapter可以一次给所有Adaptee添加功能。
- 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并使得Adapter引用这个子类而不是引用Adaptee本身。

使用Adapter模式时需要考虑的其他一些因素有：

1. Adapter的匹配程度	对Adaptee的接口与Target的接口进行匹配的工作量两个Adapter可能不一样。工作范围可能是，从简单的接口转换（例如改变操作名）到支持完全不同的操作集合。Adapter的工作量取决于Target接口与Adapter接口的相似程度。
2. 可插入的Adapter
3. 使用双向适配器提供透明操作
4. 缺省适配器模式（Default Adapter Pattern）
   定义：当不需要实现接口提供的全部方法时，可先设计一个抽象类实现该接口，并且为接口中的每个方法都提供一个默认实现（空方法），那么该抽象类的子类可以有选择地覆盖方法来实现需求。它适用于不想使用一个接口的所有方法的情况。
   在缺省适配器模式中，包含三个角色：适配者接口、缺省适配器类、具体业务类。

**相关模式：**

Bridge模式的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而可以是它们相对独立的改变。

Decorator模式增强了其他对象的功能而同时又不改变它的接口。因此decorator对应用程序的透明性更好。结果是decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。

Proxy 模式在不改变它的接口的条件下，为另一个对象定义代理。



## 桥接模式

**桥接模式（Bridge）定义：**

将抽象部分与它的实现部分分离，是他们都可以独立的变化。它是一种对象结构型模式，又称为柄体模式（Handle and Body)或接口模式（Interface）。

英文定义: Decouple an abstraction from its implementation so that the two can vary independently.

**动机：**

当一个抽象可能有多个实现时，通常用继承来协调他们。抽象类定义对该抽象的接口，而具体的子类则用不同的方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。

**适用性：**

以下情况使用Bridge模式：

- 你不希望在抽象和它的实现之间有一个固定的绑定关系。可能是因为，在程序运行时刻实现部分应可以被选择或切换。
- 类的抽象以及它的实现都因该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。
- 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。
- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**参与者：**

桥接模式包含如下角色：

- Abstraction（抽象类）
  用于定义抽象类的接口，它一般是抽象类而不是接口。
  维护一个Implementor 类型的对象引用。
  可以包含抽象的业务方法和具体的业务方法。
- RefinedAbstraction（扩充抽象类）
  扩充由 Abstraction 定义的接口。
- Implementor（实现类接口）
  定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同。一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。
  通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用 Implementor 中定义的方法，使用关联关系来替代继承关系。
- ConcreteImplementor（具体实现类）
  实现 Implementor 接口并定义它的具体实现。

**协作：**

- Abstraction将client的请求转发给它的Implementor对象。


- 在抽象类 Abstraction 中定义了一个实现类接口的成员变量impl，再通过注入的方式给该对象赋值，一般该对象的可见性定义为 protected，以便在其子类中访问 Implementor 的方法。

**效果：**

Bridge 模式有以下优点：

- 分离接口及其实现部分
  一个实现未必不变的地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现。
- 提高可扩充性
  你可以独立地对 Abstraction 和 Implementor层次结构进行扩充。
- 实现细节对客户透明
  你可以对客户隐藏实现细节，例如共享Implementor对象以及相应的引用计数机制（如果有的话）

**模式分析：**

​	理解桥接模式，重点是要理解如何将抽象化（Abstraction）和实现化（Implementation）脱耦，使得二者可以独立的变化。这里面包含了3个关键词，分别是抽象化、实现化和脱耦。

1. 抽象化
   抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面像对象中，将对象的共同性质抽取出来形成类的过程就是抽象化的过程。

2. 实现化
   针对抽象化给出的具体实现，就是实现化。抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是抽象化事物进一步具体化的产物。

3. 脱耦
   脱耦就是将抽象化和实现化之间的耦合解脱开，或者说将它们间的强关联改成弱关联，将两个角色之间的继承关系改成关联关系。桥接模式中所谓的脱耦，就是指在一个软件的抽象化和实现化之间使用关联关系（组合或聚合关系）而不是继承关系，从而使两者可以相对独立的变化，这就是桥接模式的用意。

**实现：**

1. 仅有一个Implementor
   在仅有一个实现的时候，没有必要创建一个抽象的Implementor类。这是Bridge模式的退化情况；在Abstraction和Implementor之间有一种一对一的关系。
2. 创建正确的Implementor对象
   当存在多个Implementor类的时候，应该用何种方法，在何时何处确定创建哪一个Implementor类呢？
   - 通过传入构造器的参数确定实例化哪一个类。Collection类根据大小决定实例化哪一个类。链表的实现可以用于较小的collection类，而hash表则可用于较大的collection类。
   - 首先选择一个缺省实现，然后根据需要改变这个实现。
   - 引入一个factory对象（Abstract Factory）来装配Abstraction和Implementor。这种方法的优点是Abstraction类不和任何一个Implementor类直接耦合。

**相关模式：**

Abstraction Factory 模式可以用来创建和配置一个特定的Bridge模式。

Adapter 模式用来帮助无关的类协同工作，它通常在系统设计完成后才会被使用到。然而，Bridge模式则在系统开始时就被使用，它使得抽象接口和实现部分可以独立进行改变。



## 装饰模式

**装饰模式（Decorator Pattern）定义：**

动态的给一个对象增加一些额外的职责（Responsibility），就增加对象功能来说，装饰 模式比生成子类更为灵活。

英文定义：Attach additional responsibilities to an object dynamially. Decorators provide a flexible alternative to subclassing  for extending functionality.

其别名成为包装器（Wrapper），与适配器别名相同，但它们适用于不同的场合。

**动机**

有时我们希望给某个对象而不是整个类增加一些新功能。一般有两种方式给对象或类增加行为：

1. 继承机制
   使用继承机制是给现有类添加功能的一种有效途径。通过继承一个现有的类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方法和时机。
2. 关联机制
   关联机制是更加灵活的方法，即将一个类的对象嵌入另一个类的对象中，由另一个对象来决定是否调用嵌入对象的行为并扩展新的行为，我们称这个新的对象为装饰器（Decorator）。为了使得装饰器与它所装饰的对象对客户端透明，装饰器类和被装饰的类必须实现相同的接口，装饰器将请求转发给被装饰的对象，并且可能在转发的前后执行一些额外的动作。透明性使得可以嵌套多个装饰，从而可以添加任意多的功能。

**适用性**

以下情况使用Decorator模式

- 在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责。
- 处理那些可以撤销的职责。
- 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一中情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

**参与者**

装饰模式包含如下角色：

1. Component（抽象构件）
   定义一个对象接口，可以给这些对象动态的添加职责。
   抽象构件是具体构件和抽象装饰类的共同父类。
2. ConcreteComponent（具体构件）
   定义一个对象，可以给这个对象添加一些职责
   实现了在抽象构件中声明的方法。
3. Decorator（抽象装饰类）
   维护一个指向Component对象的引用，实现一个与Component接口一致的接口。
4. ConcreteDecorator（具体装饰类）
   向组件添加新的职责。
   每一个具体装饰类都定义了一些新的行为，它可以调用抽象装饰类中定义的方法，并可以增加新的方法。

**协作**

- Decorator 将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。

**效果**

1. 比静态继承更灵活
   与对象的静态继承相比，Decorator模式提供了更加灵活的向对象添加职责的方式。可以用添加和分离的方法，用装饰在运行时刻怎加和删除职责。相比之下，继承机制要求为每个添加的职责创建一个新的子类。这会  产生许多新的类，并且会增加系统的复杂度。为一个特定的Component类提供多个不同的Decorator类，使得可以对一些职责进行混合和匹配。
2. 避免在层次结构高层的类有太多的特征
   Decorator模式提供了一种“即用即付”的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用Decorator类给他逐渐地添加功能。可以从简的部件组合出复杂的功能。这样，应用程序不必为不需要的特征付出代价。
3. Decorator 与它的Component不一样
   Decorator是一个透明的包装。如果我们从对象标志的观点出发，一个被装饰了的组件和这个组件是有差别的，因此，使用装饰时不应该依赖对象标识。
4. 有许多小对象
   采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同，而不是他们的类或是它们的属性值有所不同。

**实现**

使用Decorator模式时应注意以下几点

1. 接口的一致性
   装饰对象的接口必须与他所装饰的Component的接口是一致的，因此，所有的ConcreteDecorator必须有一个公共的父类。组件和装饰必须有一个公共的Component父类。
2. 省略抽象的Decorator类
   当你仅需要添加一个职责时，没有必要定义抽象的Decorator类。你常常需要处理现存的类层次结构而不是设计一个新系统，这时你可以把Decorator向Component转发请求的职责合并到ConcreteDecorator中。
3. 保持Component类的简单性
   为了保证接口的一致性，组件和装饰必须有一个公共的Component父类。因此保持这个类的简单性是很重要的，它应集中于定义接口而不是存储数据。对数据的表示应延迟到子类中，否则Component类会变得过于复杂和庞大，因而难以大量使用。赋予Component太多功能也使得，具体的子类有一些它们并不需要的功能的可能性大大增加。
4. 改变对象外壳与改变对象内核
   我们可以将Decorator看作一个对象的外壳，它可以改变这个对象的行为。另一种方法是改变对象的内核。Strategy模式就是一个用于改变内核的很好的模式。

**相关模式**

Adapter模式：Decorator模式不同于Adapter模式，因为装饰仅改变对象的职责而不改变它的接口；而适配器将给对象一个全新的接口。

Composite模式：可以将装饰视为一个退化的、仅有一个组件的组合。然而装饰仅给对象添加一些额外的职责，他的目的不在于对象聚合。

Strategy模式：用一个装饰你可改变对象的外表；而strategy模式使得你可以改变对象的内核。这是改变对象的两种途径。

